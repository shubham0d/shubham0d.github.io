<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="//purl.org/dc/elements/1.1/" xmlns:content="//purl.org/rss/1.0/modules/content/" xmlns:atom="//www.w3.org/2005/Atom" version="2.0" xmlns:media="//search.yahoo.com/mrss/"><channel><title><![CDATA[Security - Linuxed and reversed ]]></title><description><![CDATA[How-to's, Investigations, Reversing and nifty hacks]]></description><link>https://shubham0d.github.io/</link><image><url>https://shubham0d.github.io/favicon.png</url><title>Security - Linuxed and reversed </title><link>https://shubham0d.github.io/</link></image><generator>Ghost 1.19</generator><lastBuildDate>Sat, 30 Dec 2017 07:54:11 GMT</lastBuildDate><atom:link href="https://shubham0d.github.io/tag/security/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Sandboxing and program isolation in linux using many approaches (Part 1)]]></title><description><![CDATA[You can secure your linux system by isolating the malicious program or risky tasks using Sandboxing in different ways to stop it from affecting your main system.Sandboxing means providing a safe environment for a program or software so you can play around it without hurting your system
]]></description><link>https://shubham0d.github.io/sandboxing-and-program-isolation-in-linux-using-many-approaches/</link><guid isPermaLink="false">5a4539c707bdab0b3c6e6c34</guid><category><![CDATA[Security]]></category><category><![CDATA[Containers]]></category><category><![CDATA[Virtualization]]></category><category><![CDATA[Linux]]></category><dc:creator><![CDATA[Shubham Dubey]]></dc:creator><pubDate>Thu, 28 Dec 2017 18:58:08 GMT</pubDate><media:content url="https://shubham0d.github.io/content/images/2017/12/SandBox.jpg" medium="image"/><content:encoded><![CDATA[<div class="kg-card-markdown"><img src="https://shubham0d.github.io/content/images/2017/12/SandBox.jpg" alt="Sandboxing and program isolation in linux using many approaches (Part 1)"><p>Securing your system is a big priority for every desktop user or in production environment whether you are system admin or a software developer. The best way of secure your operating system from doubtful programs or process is by sandboxing (also termed as jailing).Sandboxing means providing a safe environment for a program or software so you can play around it without hurting your system. It actually made your program isolated from rest of the system by different features avaliable in linux kernel. Sandboxing can be useful for system adminstration if they want to test their task without any damage to system and also for developer for testing their piece of code, even it can help you to create a different environment then your base operating system.It comes in trend due to its extreme use by Paas and Saas providers.<br>
The idea of jailing is not new since it is available in unix based BSD as bsd jails and solarise as zones from years. But in linux it was started with chroot and is available due to namespaces present in linux kernel.</p>
<h1 id="namespaces">Namespaces</h1>
<p>Namespaces are features avaliable in linux to isolate process in different system resource aspects.There are 6 type of namespaces avaliable till kernel 4.0, more can be added in future</p>
<pre><code>mnt (mount points,filesystems)
pid (processes)
net (network stack)
ipc (System V IPC)
uts (hostname)
user (UIDs)
</code></pre>
<p>Linux namespace is not new,first one is added in linux in 2008 (linux kernel 2.6) but become useable more recently in linux kernel 3.6 when the work of most complex namespace user namespace has completed.Linux kernel use <em>clone</em>(),<em>unshare</em>() and <em>setns</em>() system call to create and control namespaces.Creation of new namespace is done by <em>clone</em>() system call which also use to start a process.<em>setns</em>() system call adds  a running process to the existing namespace.<em>unshare</em>() call work on process inside namespace and make the caller member of namespace.Its main purpose is also to isolate namespace without having to create a new process or thread (as is done by clone()).You can directly use some services to get the feature of these namespaces.The CLONE_NEW* identifiers is use with these system call to indentify the type of namespace.these three system calls make use of the CLONE_NEW*  as CLONE_NEWIPC , CLONE_NEWNS , CLONE_NEWNET , CLONE_NEWPID , CLONE_NEWUSER , and CLONE_NEWUTS .Process in a namespace can be differ by its unique inode number when it is created.</p>
<pre><code>#ls -al /proc/&lt;pid&gt;/ns
lrwxrwxrwx 1 root root 0 Feb  7 13:52 ipc -&gt; ipc:[4026532253]
lrwxrwxrwx 1 root root 0 Feb  7 15:39 mnt -&gt; mnt:[4026532251]
lrwxrwxrwx 1 root root 0 Feb  7 13:52 net -&gt; net:[4026531957]
lrwxrwxrwx 1 root root 0 Feb  7 13:52 pid -&gt; pid:[4026532254]
lrwxrwxrwx 1 root root 0 Feb  7 13:52 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0 Feb  7 15:39 uts -&gt; uts:[4026532252]
</code></pre>
<h3 id="mountnamespace">Mount namespace:-</h3>
<p>Process view diffrent mount point then the original system mount point /.It create a seprate filesystem tree associated with different process which restrict them to make changes to the root filesystem.</p>
<h3 id="pidnamespace">Pid namespace</h3>
<p>Pid namespace isolate a process ID from the main pid hierarchy.A process inside a pid namespace can have same pid as a process outside it and even inside namespace you can have different init with pid 1.</p>
<h3 id="utsnamespace">Uts namespace:-</h3>
<p>In uts (Unix Timesharing system) namespace a process can have different set of domainname and hostname then the main system.They use sethostname() and setdomainname() to do that.</p>
<h3 id="ipcnamespace">IPC namespace:-</h3>
<p>Use for interprocess communication resources isolation and POSIX message queue.</p>
<h3 id="usernamespace">User namespace:-</h3>
<p>It isolate user and group id inside a namespace which allow to have same uid or gid in namespace as in host machine.In your system unprivileged process can create user namespaces in which they have full privileges.</p>
<h3 id="networknamespaces">Network namespaces:-</h3>
<p>Inside this namespace processes can have different network stack i.e different network device,ip address,routing table etc.</p>
<p>Sandboxing tools avaliable in linux use these feature namespaces to isolate process or create new virtual enviornment.A much secure tool will be that which use maximum namespace for isolation.Now lets talk about different methods for sandboxing from soft to hard isolation.</p>
<h1 id="chroot">chroot</h1>
<p>chroot is the oldest sandboxing tool avaliable in linux.Its work is same as mount namespace but is implemented much earlier then that. chroot change the root directory for a process to any chroot directory(like /chroot).As the root directory is the top of the filesystem hierarchy, applications are unable to access directories higher up than the root directory, and so are isolated from the rest of the system. This prevents applications inside the chroot from interfering with files elsewhere on your computer.To create a isolated environment in old SystemV based operating system first you need to copy all required packages and libraries to that directory.<br>
For demonstration I am running &quot;<em>ls</em>&quot; on chroot directory.<br>
First create a directory to set as root filesystem for a process:-</p>
<pre><code>$mkdir /chroot
</code></pre>
<p>make important required directories inside it.</p>
<pre><code>$mkdir /chroot/{lib,lib64,bin,etc} 
</code></pre>
<p>To get shell inside the chroot you need /<em>bin/bash</em>.</p>
<pre><code>$cp -v /bin/{bash,ls} /chroot/bin
</code></pre>
<p>Now the most important step is to copy the executable and libraries.To  see libraries required for these script run:</p>
<pre><code>$ldd /bin/bash
linux-vdso.so.1 (0x00007fff70deb000)
libncurses.so.5 =&gt; /lib/x86_64-linux-gnu/libncurses.so.5 (0x00007f25e33a9000)
libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f25e317f000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f25e2f7a000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f25e2bd6000)
/lib64/ld-linux-x86-64.so.2 (0x00007f25e360d000)
</code></pre>
<pre><code>$ldd /bin/ls
linux-vdso.so.1 (0x00007fff4f8e6000)
libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9f00aec000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9f00748000)
libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f9f004d7000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f9f002d3000)
/lib64/ld-linux-x86-64.so.2 (0x00007f9f00d4f000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f9f000b6000)
</code></pre>
<p>now copy these files to the lib or lib64 of /chroot as required.<br>
Once you have copied all the necessary file.Its time to enter the chroot.</p>
<pre><code>$sudo chroot /chroot/ /bin/bash
</code></pre>
<p>you will be prompt with a shell running inside your virtual environment.Here you don't have much things to run beside '<em>ls</em>' but it has changed the root filesystem for the process to /chroot.<br>
To get more featured enviornment you can use debootstrap utility to bootstrap a basic debian system</p>
<pre><code>$debootstrap --arch=amd64 unstable my_deb/
</code></pre>
<p>it will download a minimal system to run under chroot.You can use this to even test 32-bit applications on 64-bit systems or for testing your program before installation.To get process management mount <em>proc</em> and other important filesystem to the chroot and to make the content of home lost on exit mount <em>tmpfs</em> at /home//</p>
<pre><code>$sudo mount -o bind /proc my_deb/proc
$mount -o bind /dev my_deb/dev
$mount -t sysfs sysfs my_deb//sys

$mount -t tmpfs -o size=100m tmpfs /home/user
</code></pre>
<p>to get internet connection inside</p>
<pre><code>$sudo cp /etc/resolv.conf /var/chroot/etc/resolv.conf
</code></pre>
<p>after that  you are ready to enter inside your enviornment.</p>
<pre><code>$chroot my_deb/ /bin/bash
</code></pre>
<p>Here you get a minimal linux distribution inside your chroot.But it only differ from your host system by mount point only since it only uses mount property as isolator. It has same hostname,ip addr and process running as in the host system. That's why it is very less secure (even given in the man page of chroot) and any running process can still harm your computer by killing your tasks or affecting network based services.</p>
<blockquote>
<p><strong>Note</strong>:<br>
To run graphical applications inside chroot open x server by running this on host system</p>
<pre><code>$xhost +
</code></pre>
<p>and on chroot system</p>
<pre><code>$export DISPLAY=:0.0
</code></pre>
</blockquote>
<p>On systemd based linux chrooting become preety straight forward. Its needed to define the root directory on the processes as unit file only.</p>
<pre><code>[Unit]
Description=my_chroot_Service
[Service]
RootDirectory=/chroot/foobar
ExecStartPre=/usr/local/bin/pre.sh
ExecStart=/bin/my_program
RootDirectoryStartOnly=yes
</code></pre>
<p>Here <em>RootDirectory=</em> define where the root directory have to be for foobard process.</p>
<blockquote>
<p><strong>Note</strong>:<br>
The program script path have to be inside chroot, that make the full path of that process script as /chroot/bin/my_program'</p>
</blockquote>
<p>Before the daemon is started a shell script pre.sh is invoked, whose purpose is to set up the chroot environment, i.e. mount /proc and similar file systems into it, depending on what the service might need. You can start your service by</p>
<pre><code>#systemctl start my_chroot_Service.service
</code></pre>
<h1 id="ipnetns">Ip-netns</h1>
<p>Ip-netns utility is few of utility that directly use network namespace to create virtual interfaces.<br>
To create a new network namespace use</p>
<pre><code>$ip netns add netns1
</code></pre>
<p>To check the interfaces inside</p>
<pre><code>$ip netns exec netns ip addr
</code></pre>
<p>you can even get the shell inside it</p>
<pre><code>$ip netns exec netns /bin/bash
</code></pre>
<p>this will take you inside the network namespace which had only single network interface with no ip.So,we are not connected with the external network and hence can't ping.</p>
<pre><code>$ip netns exec netns ip link set dev lo up
</code></pre>
<p>this will bring the loop interface up.But to connect to external network you need to create a virtual ethernet and add it to netns</p>
<pre><code>$ ip link add veth0 type veth peer name veth1
$ ip link set veth1 netns netns1
</code></pre>
<p>now its time to set the ip to these interfaces</p>
<pre><code>$ ip netns exec netns1 ifconfig veth1 10.1.1.1/24 up
$ ifconfig veth0 10.1.1.2/24 up
</code></pre>
<h1 id="unshare">Unshare</h1>
<p>Unshare utility is used to create any namespaces isolated environment and run a program or shell inside it.<br>
To get a network namespace and run shell inside it</p>
<pre><code>$unshare --net /bin/bash
</code></pre>
<p>The shell you get back will come with different network stack.You can check this by</p>
<pre><code>$ip addr
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre>
<p>To create a user namespace enviornment.</p>
<pre><code>$unshare --user /bin/bash
</code></pre>
<p>you can check your user inside shell by</p>
<pre><code>$whoami
nobody
</code></pre>
<p>To get pid namespace</p>
<pre><code>$unshare --pid --fork /bin/bash
</code></pre>
<p>inside this namespace you can see all the process but cannot kill anyone.</p>
<pre><code>$ps -aux |grep firefox
root      1110 42.6 11.0 1209424 436756 tty1   Sl   23:36   0:15 .firefox1/./firefox
root      1208  0.0  0.0  12660  1648 pts/2    S+   23:37   0:00 grep firefox
$kill 1110
bash: kill: (1110) - No such process
</code></pre>
<p>To get whole different process tree isolation you need to mount another proc for namespace</p>
<pre><code>unshare --pid --fork --mount-proc /bin/bash
</code></pre>
<p>In this way you can use unshare to create single namespace.More can be found on man page of unshare.</p>
<p>*** Thats it for this part. In the next part we will look into some more tools for sandboxing. Stay tuned! ***</p>
</div>]]></content:encoded></item></channel></rss>